Depth <- equal.count(quakes$depth, number=8, overlap=.1)
xyplot(lat ~ long | Depth, data = quakes)
gridToSVG(name=tempsvg)
dev.off()
tempsvg
readLines(tempsvg,n=-1)
runApp("C:\\Users\\Kent.TLEAVELL_NT\\Dropbox\\development\\r\\shiny-grid-svg")
runApp("C:\\Users\\Kent.TLEAVELL_NT\\Dropbox\\development\\r\\shiny-grid-svg")
runApp("C:\\Users\\Kent.TLEAVELL_NT\\Dropbox\\development\\r\\shiny-grid-svg")
svgoutput
svgoutput <- readLines(tempsvg,n=-1)
cat(svgoutput)
runApp("C:\\Users\\Kent.TLEAVELL_NT\\Dropbox\\development\\r\\shiny-grid-svg")
runApp("C:\\Users\\Kent.TLEAVELL_NT\\Dropbox\\development\\r\\shiny-grid-svg")
runApp("C:\\Users\\Kent.TLEAVELL_NT\\Dropbox\\development\\r\\shiny-grid-svg")
tempsvg <- tempfile(fileext=".svg")
Depth <- equal.count(quakes$depth, number=8, overlap=.1)
xyplot(lat ~ long | Depth, data = quakes)
gridToSVG(name=tempsvg)
dev.off()
runApp("C:\\Users\\Kent.TLEAVELL_NT\\Dropbox\\development\\r\\shiny-grid-svg")
runApp("C:\\Users\\Kent.TLEAVELL_NT\\Dropbox\\development\\r\\shiny-grid-svg")
runApp("C:\\Users\\Kent.TLEAVELL_NT\\Dropbox\\development\\r\\shiny-grid-svg")
runApp("C:\\Users\\Kent.TLEAVELL_NT\\Dropbox\\development\\r\\shiny-grid-svg")
Depth <- equal.count(quakes$depth, number=8, overlap=.1)
xyplot(lat ~ long | Depth, data = quakes)
gridToSVG(name=tempsvg)
dev.off()
gridToSVG(name=tempsvg)
(gridToSVG(name=tempsvg))
Depth <- equal.count(quakes$depth, number=8, overlap=.1)
xyplot(lat ~ long | Depth, data = quakes)
(gridToSVG(name=tempsvg))
?bwplot
bwplot(voice.part ~ height, data=singer, xlab="Height (inches)")
xyplot.example <- function(){
#from lattice package documentation
Depth <- equal.count(quakes$depth, number=8, overlap=.1)
xyplot(lat ~ long | Depth, data = quakes)
}
bwplot.example <- function() {
#from lattice package documentation
bwplot(voice.part ~ height, data=singer, xlab="Height (inches)")
}
match.call("bwplot.example")
get("bwplot.example")
get("bwplot.example")()
get("bwplot.example")()
runApp("C:\\Users\\Kent.TLEAVELL_NT\\Dropbox\\development\\r\\shiny-grid-svg")
runApp("C:\\Users\\Kent.TLEAVELL_NT\\Dropbox\\development\\r\\shiny-grid-svg")
runApp("C:\\Users\\Kent.TLEAVELL_NT\\Dropbox\\development\\r\\shiny-grid-svg")
createSVG <- reactive(function() {
xyplot.example <- function() {
#from lattice package documentation
Depth <- equal.count(quakes$depth, number=8, overlap=.1)
xyplot(lat ~ long | Depth, data = quakes)
}
bwplot.example <- function() {
#from lattice package documentation
bwplot(voice.part ~ height, data=singer, xlab="Height (inches)")
}
get(paste("bwplot","example",sep="."))()
#get(paste(input$example,"example",sep="."))()
tempsvg <- tempfile(fileext=".svg")
gridToSVG(name=tempsvg)
return(tempsvg)
}
)
createSVG()
runApp("C:\\Users\\Kent.TLEAVELL_NT\\Dropbox\\development\\r\\shiny-grid-svg")
runApp("C:\\Users\\Kent.TLEAVELL_NT\\Dropbox\\development\\r\\shiny-grid-svg")
runApp("C:\\Users\\Kent.TLEAVELL_NT\\Dropbox\\development\\r\\shiny-grid-svg")
runApp("C:\\Users\\Kent.TLEAVELL_NT\\Dropbox\\development\\r\\shiny-grid-svg")
runApp("C:\\Users\\Kent.TLEAVELL_NT\\Dropbox\\development\\r\\shiny-grid-svg")
xyplot.example <- xyplot(lat ~ long | Depth, data = quakes)
bwplot.example <- bwplot(voice.part ~ height, data=singer, xlab="Height (inches)")
runApp("C:\\Users\\Kent.TLEAVELL_NT\\Dropbox\\development\\r\\shiny-grid-svg")
print(exampleInput())
exampleInput <-
function(){
paste(input$example,"example",sep=".")
}
xyplot.example <- xyplot(lat ~ long | Depth, data = quakes)
bwplot.example <- bwplot(voice.part ~ height, data=singer, xlab="Height (inches)")
print(exampleInput())
paste("bwplot","example","sep="."")
paste("bwplot","example","sep=".")
paste("bwplot","example",sep=".")
print(paste("bwplot","example",sep="."))
print(get(paste("bwplot","example",sep=".")))
tempsvg <- tempfile(fileext=".svg")
gridToSVG(name=tempsvg)
xyplot.example <- xyplot(lat ~ long | Depth, data = quakes)
exampleInput <-
function(){
paste("xyplot","example",sep=".")
#paste(input$example,"example",sep=".")
}
print(get(exampleInput()))
tempsvg <- tempfile(fileext=".svg")
gridToSVG(name=tempsvg)
svgoutput <- readLines(tempsvg, n=-1)
svgoutput
runApp("C:\\Users\\Kent.TLEAVELL_NT\\Dropbox\\development\\r\\shiny-grid-svg")
runApp("C:\\Users\\Kent.TLEAVELL_NT\\Dropbox\\development\\r\\shiny-grid-svg")
?xyplot
dotplot(variety ~ yield | site, data = barley, groups = year,
key = simpleKey(levels(barley$year), space = "right"),
xlab = "Barley Yield (bushels/acre) ",
aspect=0.5, layout = c(1,6), ylab=NULL)
gridToSVG(name=tempsvg)
runApp("C:\\Users\\Kent.TLEAVELL_NT\\Dropbox\\development\\r\\shiny-grid-svg")
?lattice
?dotplot
barchart(yield ~ variety | site, data = barley,
groups = year, layout = c(1,6), stack = TRUE,
auto.key = list(space = "right"),
ylab = "Barley Yield (bushels/acre)",
scales = list(x = list(rot = 45)))
gridToSVG(name=tempsvg)
runApp("C:\\Users\\Kent.TLEAVELL_NT\\Dropbox\\development\\r\\shiny-grid-svg")
runApp("C:\\Users\\Kent.TLEAVELL_NT\\Dropbox\\development\\r\\shiny-grid-svg")
runApp("C:\\Users\\Kent.TLEAVELL_NT\\Dropbox\\development\\r\\shiny-grid-svg")
runApp("C:\\Users\\Kent.TLEAVELL_NT\\Dropbox\\development\\r\\shiny-grid-svg")
HTML("Motivated by the very fine work of Paul Murrell in this <a href=\"http://www.stat.auckland.ac.nz/~paul/Reports/ggplotSlider/ggplotSlider.html\"Technical Report</a>
and <a href=\"http://journal.r-project.org/current.html\"articles recently published</a> I will show how to send
grid graphics as SVG to the browser with Shiny")
runApp("C:\\Users\\Kent.TLEAVELL_NT\\Dropbox\\development\\r\\shiny-grid-svg")
paste("Motivated by the very fine work of Paul Murrell in this ",
HTML("<a href=\"http://www.stat.auckland.ac.nz/~paul/Reports/ggplotSlider/ggplotSlider.html\">Technical Report</a>"),
HTML("and <a href=\"http://journal.r-project.org/current.html\">articles recently published</a> I will show how to send"),
"grid graphics as SVG to the browser with Shiny",sep="")
runApp("C:\\Users\\Kent.TLEAVELL_NT\\Dropbox\\development\\r\\shiny-grid-svg")
runApp("C:\\Users\\Kent.TLEAVELL_NT\\Dropbox\\development\\r\\shiny-grid-svg")
runApp("C:\\Users\\Kent.TLEAVELL_NT\\Dropbox\\development\\r\\shiny-grid-svg")
runApp("C:\\Users\\Kent.TLEAVELL_NT\\Dropbox\\development\\r\\shiny-grid-svg")
runApp("C:\\Users\\Kent.TLEAVELL_NT\\Dropbox\\development\\r\\shiny-grid-svg")
runApp("C:\\Users\\Kent.TLEAVELL_NT\\Dropbox\\development\\r\\shiny-grid-svg")
runApp("C:\\Users\\Kent.TLEAVELL_NT\\Dropbox\\development\\r\\shiny-grid-svg")
runApp("C:\\Users\\Kent.TLEAVELL_NT\\Dropbox\\development\\r\\shiny-grid-svg")
runApp("C:\\Users\\Kent.TLEAVELL_NT\\Dropbox\\development\\r\\shiny-grid-svg")
runApp("C:\\Users\\Kent.TLEAVELL_NT\\Dropbox\\development\\r\\shiny-grid-svg")
runApp("C:\\Users\\Kent.TLEAVELL_NT\\Dropbox\\development\\r\\shiny-grid-svg")
runApp("C:\\Users\\Kent.TLEAVELL_NT\\Dropbox\\development\\r\\shiny-grid-svg")
runApp("C:\\Users\\Kent.TLEAVELL_NT\\Dropbox\\development\\r\\shiny-grid-svg")
#does not contain the linear forecast piece that makes this system extremely good
library(quantmod)
library(TTR)
library(PerformanceAnalytics)
tckr<-"^GSPC"
start<-"1919-01-01"
end<- format(Sys.Date(),"%Y-%m-%d") # yyyy-mm-dd
# Pull tckr index data from Yahoo! Finance
getSymbols(tckr, from=start, to=end)
GSPC<-adjustOHLC(GSPC,use.Adjusted=T)
GSPC.cl<-GSPC[,4]
GSPC.H<-GSPC[,2]
GSPC.L<-GSPC[,3]
avg250<-runMean(GSPC.cl,n=250)
avg250<-GSPC.cl-avg250
roc<-ROC(GSPC.cl,n=1)+1
roc[is.na(roc)] <- 0
roc10<-ROC(GSPC.cl,n=10)
roc200<-ROC(GSPC.cl,n=200)
signal2<-roc200-roc10
cortime<-runCor(roc,as.numeric(index(roc)),n=21)
coritself<-runCor(roc,roc200,n=120)
signal<-2*sign(avg250)+.5*sign(cortime)+sign(coritself)
signal<-runSum(signal,6)
# Create the long (up) and short (dn) signals
sigup <- ifelse(signal>=0&signal2<0.27,1,0)
# Lag signals to align with days in market,
# not days signals were generated
sigup <- lag(sigup,1) # Note k=1 implies a move *forward*
# Replace missing signals with no position
# (generally just at beginning of series)
sigup[is.na(sigup)] <- 0
#Calculate Close-to-Close returns
ret <- GSPC[,6]/lag(GSPC[,6])-1
ret[1] <- 0
#Calculate equity curves
eq_up <- cumprod(1+ret*sigup)
plot(log(eq_up))
systemmonth<-to.monthly(eq_up)
indexmonth<-to.monthly(GSPC)
indexperf<-monthlyReturn(indexmonth)
systemperf<-monthlyReturn(systemmonth)
mergeperf<-merge(indexperf,systemperf)
index(mergeperf)<-as.Date(index(mergeperf))
charts.PerformanceSummary(mergeperf,ylog=TRUE)
table.DownsideRisk(mergeperf)
#systemdayperf<-dailyReturn(to.daily(eq_up))
#table.Drawdowns(systemdayperf)
chartSeries(GSPC,TA="addTA(eq_up*coredata(GSPC)[1,4],on=1);addTA(signal);addTA(signal2)",log=T)
#does not contain the linear forecast piece that makes this system extremely good
library(quantmod)
library(TTR)
library(PerformanceAnalytics)
tckr<-"VFWIX"
start<-"1919-01-01"
end<- format(Sys.Date(),"%Y-%m-%d") # yyyy-mm-dd
# Pull tckr index data from Yahoo! Finance
getSymbols(tckr, from=start, to=end)
VFWIX<-adjustOHLC(VFWIX,use.Adjusted=T)
VFWIX.cl<-VFWIX[,4]
VFWIX.H<-VFWIX[,2]
VFWIX.L<-VFWIX[,3]
avg250<-runMean(VFWIX.cl,n=250)
avg250<-VFWIX.cl-avg250
roc<-ROC(VFWIX.cl,n=1)+1
roc[is.na(roc)] <- 0
roc10<-ROC(VFWIX.cl,n=10)
roc200<-ROC(VFWIX.cl,n=200)
signal2<-roc200-roc10
cortime<-runCor(roc,as.numeric(index(roc)),n=21)
coritself<-runCor(roc,roc200,n=120)
signal<-2*sign(avg250)+.5*sign(cortime)+sign(coritself)
signal<-runSum(signal,6)
# Create the long (up) and short (dn) signals
sigup <- ifelse(signal>=0&signal2<0.27,1,0)
# Lag signals to align with days in market,
# not days signals were generated
sigup <- lag(sigup,1) # Note k=1 implies a move *forward*
# Replace missing signals with no position
# (generally just at beginning of series)
sigup[is.na(sigup)] <- 0
#Calculate Close-to-Close returns
ret <- VFWIX[,6]/lag(VFWIX[,6])-1
ret[1] <- 0
#Calculate equity curves
eq_up <- cumprod(1+ret*sigup)
plot(log(eq_up))
systemmonth<-to.monthly(eq_up)
indexmonth<-to.monthly(VFWIX)
indexperf<-monthlyReturn(indexmonth)
systemperf<-monthlyReturn(systemmonth)
mergeperf<-merge(indexperf,systemperf)
index(mergeperf)<-as.Date(index(mergeperf))
charts.PerformanceSummary(mergeperf,ylog=TRUE)
table.DownsideRisk(mergeperf)
#systemdayperf<-dailyReturn(to.daily(eq_up))
#table.Drawdowns(systemdayperf)
chartSeries(VFWIX,TA="addTA(eq_up*coredata(VFWIX)[1,4],on=1);addTA(signal);addTA(signal2)",log=T)
#does not contain the linear forecast piece that makes this system extremely good
library(quantmod)
library(TTR)
library(PerformanceAnalytics)
tckr<-"VGSTX"
start<-"1919-01-01"
end<- format(Sys.Date(),"%Y-%m-%d") # yyyy-mm-dd
# Pull tckr index data from Yahoo! Finance
getSymbols(tckr, from=start, to=end)
VGSTX<-adjustOHLC(VGSTX,use.Adjusted=T)
VGSTX.cl<-VGSTX[,4]
VGSTX.H<-VGSTX[,2]
VGSTX.L<-VGSTX[,3]
avg250<-runMean(VGSTX.cl,n=250)
avg250<-VGSTX.cl-avg250
roc<-ROC(VGSTX.cl,n=1)+1
roc[is.na(roc)] <- 0
roc10<-ROC(VGSTX.cl,n=10)
roc200<-ROC(VGSTX.cl,n=200)
signal2<-roc200-roc10
cortime<-runCor(roc,as.numeric(index(roc)),n=21)
coritself<-runCor(roc,roc200,n=120)
signal<-2*sign(avg250)+.5*sign(cortime)+sign(coritself)
signal<-runSum(signal,6)
# Create the long (up) and short (dn) signals
sigup <- ifelse(signal>=0&signal2<0.27,1,0)
# Lag signals to align with days in market,
# not days signals were generated
sigup <- lag(sigup,1) # Note k=1 implies a move *forward*
# Replace missing signals with no position
# (generally just at beginning of series)
sigup[is.na(sigup)] <- 0
#Calculate Close-to-Close returns
ret <- VGSTX[,6]/lag(VGSTX[,6])-1
ret[1] <- 0
#Calculate equity curves
eq_up <- cumprod(1+ret*sigup)
plot(log(eq_up))
systemmonth<-to.monthly(eq_up)
indexmonth<-to.monthly(VGSTX)
indexperf<-monthlyReturn(indexmonth)
systemperf<-monthlyReturn(systemmonth)
mergeperf<-merge(indexperf,systemperf)
index(mergeperf)<-as.Date(index(mergeperf))
charts.PerformanceSummary(mergeperf,ylog=TRUE)
table.DownsideRisk(mergeperf)
#systemdayperf<-dailyReturn(to.daily(eq_up))
#table.Drawdowns(systemdayperf)
chartSeries(VGSTX,TA="addTA(eq_up*coredata(VGSTX)[1,4],on=1);addTA(signal);addTA(signal2)",log=T)
#does not contain the linear forecast piece that makes this system extremely good
library(quantmod)
library(TTR)
library(PerformanceAnalytics)
tckr<-"VFWIX"
start<-"1919-01-01"
end<- format(Sys.Date(),"%Y-%m-%d") # yyyy-mm-dd
# Pull tckr index data from Yahoo! Finance
getSymbols(tckr, from=start, to=end)
VFWIX<-adjustOHLC(VFWIX,use.Adjusted=T)
VFWIX.cl<-VFWIX[,4]
VFWIX.H<-VFWIX[,2]
VFWIX.L<-VFWIX[,3]
avg250<-runMean(VFWIX.cl,n=250)
avg250<-VFWIX.cl-avg250
roc<-ROC(VFWIX.cl,n=1)+1
roc[is.na(roc)] <- 0
roc10<-ROC(VFWIX.cl,n=10)
roc200<-ROC(VFWIX.cl,n=200)
signal2<-roc200-roc10
cortime<-runCor(roc,as.numeric(index(roc)),n=21)
coritself<-runCor(roc,roc200,n=120)
signal<-2*sign(avg250)+.5*sign(cortime)+sign(coritself)
signal<-runSum(signal,6)
# Create the long (up) and short (dn) signals
sigup <- ifelse(signal>=0&signal2<0.27,1,0)
# Lag signals to align with days in market,
# not days signals were generated
sigup <- lag(sigup,1) # Note k=1 implies a move *forward*
# Replace missing signals with no position
# (generally just at beginning of series)
sigup[is.na(sigup)] <- 0
#Calculate Close-to-Close returns
ret <- VFWIX[,6]/lag(VFWIX[,6])-1
ret[1] <- 0
#Calculate equity curves
eq_up <- cumprod(1+ret*sigup)
plot(log(eq_up))
systemmonth<-to.monthly(eq_up)
indexmonth<-to.monthly(VFWIX)
indexperf<-monthlyReturn(indexmonth)
systemperf<-monthlyReturn(systemmonth)
mergeperf<-merge(indexperf,systemperf)
index(mergeperf)<-as.Date(index(mergeperf))
charts.PerformanceSummary(mergeperf,ylog=TRUE)
table.DownsideRisk(mergeperf)
#systemdayperf<-dailyReturn(to.daily(eq_up))
#table.Drawdowns(systemdayperf)
chartSeries(VFWIX,TA="addTA(eq_up*coredata(VFWIX)[1,4],on=1);addTA(signal);addTA(signal2)",log=T)
SIUP
tail(sigup)
sigup["2012-06"]
sigup["2012-06::"]
#does not contain the linear forecast piece that makes this system extremely good
library(quantmod)
library(TTR)
library(PerformanceAnalytics)
tckr<-"veiex"
start<-"1919-01-01"
end<- format(Sys.Date(),"%Y-%m-%d") # yyyy-mm-dd
# Pull tckr index data from Yahoo! Finance
getSymbols(tckr, from=start, to=end)
veiex<-adjustOHLC(veiex,use.Adjusted=T)
veiex.cl<-veiex[,4]
veiex.H<-veiex[,2]
veiex.L<-veiex[,3]
avg250<-runMean(veiex.cl,n=250)
avg250<-veiex.cl-avg250
roc<-ROC(veiex.cl,n=1)+1
roc[is.na(roc)] <- 0
roc10<-ROC(veiex.cl,n=10)
roc200<-ROC(veiex.cl,n=200)
signal2<-roc200-roc10
cortime<-runCor(roc,as.numeric(index(roc)),n=21)
coritself<-runCor(roc,roc200,n=120)
signal<-2*sign(avg250)+.5*sign(cortime)+sign(coritself)
signal<-runSum(signal,6)
# Create the long (up) and short (dn) signals
sigup <- ifelse(signal>=0&signal2<0.27,1,0)
# Lag signals to align with days in market,
# not days signals were generated
sigup <- lag(sigup,1) # Note k=1 implies a move *forward*
# Replace missing signals with no position
# (generally just at beginning of series)
sigup[is.na(sigup)] <- 0
#Calculate Close-to-Close returns
ret <- veiex[,6]/lag(veiex[,6])-1
ret[1] <- 0
#Calculate equity curves
eq_up <- cumprod(1+ret*sigup)
plot(log(eq_up))
systemmonth<-to.monthly(eq_up)
indexmonth<-to.monthly(veiex)
indexperf<-monthlyReturn(indexmonth)
systemperf<-monthlyReturn(systemmonth)
mergeperf<-merge(indexperf,systemperf)
index(mergeperf)<-as.Date(index(mergeperf))
charts.PerformanceSummary(mergeperf,ylog=TRUE)
table.DownsideRisk(mergeperf)
#systemdayperf<-dailyReturn(to.daily(eq_up))
#table.Drawdowns(systemdayperf)
chartSeries(veiex,TA="addTA(eq_up*coredata(veiex)[1,4],on=1);addTA(signal);addTA(signal2)",log=T)
#does not contain the linear forecast piece that makes this system extremely good
library(quantmod)
library(TTR)
library(PerformanceAnalytics)
tckr<-"VEIEX"
start<-"1919-01-01"
end<- format(Sys.Date(),"%Y-%m-%d") # yyyy-mm-dd
# Pull tckr index data from Yahoo! Finance
getSymbols(tckr, from=start, to=end)
VEIEX<-adjustOHLC(VEIEX,use.Adjusted=T)
VEIEX.cl<-VEIEX[,4]
VEIEX.H<-VEIEX[,2]
VEIEX.L<-VEIEX[,3]
avg250<-runMean(VEIEX.cl,n=250)
avg250<-VEIEX.cl-avg250
roc<-ROC(VEIEX.cl,n=1)+1
roc[is.na(roc)] <- 0
roc10<-ROC(VEIEX.cl,n=10)
roc200<-ROC(VEIEX.cl,n=200)
signal2<-roc200-roc10
cortime<-runCor(roc,as.numeric(index(roc)),n=21)
coritself<-runCor(roc,roc200,n=120)
signal<-2*sign(avg250)+.5*sign(cortime)+sign(coritself)
signal<-runSum(signal,6)
# Create the long (up) and short (dn) signals
sigup <- ifelse(signal>=0&signal2<0.27,1,0)
# Lag signals to align with days in market,
# not days signals were generated
sigup <- lag(sigup,1) # Note k=1 implies a move *forward*
# Replace missing signals with no position
# (generally just at beginning of series)
sigup[is.na(sigup)] <- 0
#Calculate Close-to-Close returns
ret <- VEIEX[,6]/lag(VEIEX[,6])-1
ret[1] <- 0
#Calculate equity curves
eq_up <- cumprod(1+ret*sigup)
plot(log(eq_up))
systemmonth<-to.monthly(eq_up)
indexmonth<-to.monthly(VEIEX)
indexperf<-monthlyReturn(indexmonth)
systemperf<-monthlyReturn(systemmonth)
mergeperf<-merge(indexperf,systemperf)
index(mergeperf)<-as.Date(index(mergeperf))
charts.PerformanceSummary(mergeperf,ylog=TRUE)
table.DownsideRisk(mergeperf)
#systemdayperf<-dailyReturn(to.daily(eq_up))
#table.Drawdowns(systemdayperf)
chartSeries(VEIEX,TA="addTA(eq_up*coredata(VEIEX)[1,4],on=1);addTA(signal);addTA(signal2)",log=T)
tail(sigup,100)
require(UsingR)
require(lessR)
require(reshape)
require(gplots)
require(plyr)
require(lattice)
require(latticeExtra)
clientPerf <- read.csv("u:\\perf_exp.csv",stringsAsFactors=FALSE)
#clientPerf <- read.csv("c:\\windows\\temp\\perf_exp.csv",stringsAsFactors=FALSE)
clientPerf[,5:(NCOL(clientPerf)-1)] <- lapply(clientPerf[,5:(NCOL(clientPerf)-1)],as.numeric)
clientPerf <- clientPerf[!is.na(clientPerf)[,5],1:6]
means <- ddply(clientPerf,.(portmanager,counselor),summarise,mean_ytd=mean(ytd,na.rm=TRUE))
means.tgt <- ddply(clientPerf,.(portmanager,floor(clientPerf$equity/25)),summarise,mean_ytd=mean(ytd,na.rm=TRUE))
colnames(means.tgt)[2]<-"equity"
dotplot(portmanager~mean_ytd|counselor,group=counselor,data=means,
horiz=TRUE,layout=c(1,6),cex=2,
scales=list(y=list(alternating=2)),
par.settings=theEconomist.theme(box="transparent"),
lattice.options=theEconomist.opts(),
xlim=c(-10,10),
main="Performance for 2012 by Counselor")+
layer(panel.abline(v=0,col="gray70"))
dotplot(counselor~mean_ytd|portmanager,group=portmanager,data=means,
horiz=TRUE,layout=c(1,9),cex=2,
scales=list(y=list(alternating=2)),
par.settings=theEconomist.theme(box="transparent"),
lattice.options=theEconomist.opts(),
xlim=c(-10,10),
main="Performance for 2012 by Manager")+
layer(panel.abline(v=0,col="gray70"))
dotplot(portmanager~mean_ytd|factor(equity),group=portmanager,data=means.tgt,
horiz=TRUE,layout=c(1,5),cex=2,
scales=list(y=list(alternating=2)),
par.settings=theEconomist.theme(box="transparent"),
lattice.options=theEconomist.opts(),
xlim=c(-10,10),
main="Performance for 2012 by Equity Target")+
layer(panel.abline(v=0,col="gray70"))
dotplot(factor(equity)~mean_ytd|portmanager,group=equity,data=means.tgt,
horiz=TRUE,layout=c(1,7),cex=2,
scales=list(y=list(alternating=2)),
par.settings=theEconomist.theme(box="transparent"),
lattice.options=theEconomist.opts(),
xlim=c(-10,10),
main="Performance for 2012 by Equity Target")+
layer(panel.abline(v=0,col="gray70"))
client_Melt <- melt(clientPerf[,c(2,3,1,5)],id.vars=1:3)
client.melt <- na.omit(client_Melt)
colnames(client.melt) <- c("manager","counselor","account","period","return")
require(directlabels)
direct.label(
densityplot(~return,groups=manager,data=client.melt,xlim=c(-10,10))
)
stripchart(clientPerf[,4]~clientPerf[,2],method="jitter",vertical=TRUE,pch=19)
stripchart(clientPerf[,2:3],vertical=TRUE,pch=19,col=2)
simple.eda(clientPerf[,4])
color.boxplot.n(clientPerf[,4]~clientPerf[,3],col.box="palegreen1",
col.point="plum", show.values=TRUE, horizontal = FALSE)
dotplot(factor(equity)~mean_ytd|portmanager,group=equity,data=means.tgt,
horiz=TRUE,layout=c(1,7),cex=2,
scales=list(y=list(alternating=2)),
par.settings=theEconomist.theme(box="transparent"),
lattice.options=theEconomist.opts(),
xlim=c(-10,10),
main="Performance for 2012 by Equity Target")+
layer(panel.abline(v=0,col="gray70"))
require(shiny)
runApp("C:\\Users\\Kent.TLEAVELL_NT\\Dropbox\\development\\r\\shiny-d3-scatterplot")
