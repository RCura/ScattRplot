require(gdalUtils)
require(shiny)
require(d3Networks)
require(devtools)
devtools::install_github("d3Network", "christophergandrud")
require(d3Networks)
require(d3networks)
require(d3Network)
?d3Network::d3ForceNetwork
data(MisLinks)
data(MisNodes)
# Create graph
d3ForceNetwork(Links = MisLinks, Nodes = MisNodes, Source = "source",
Target = "target", Value = "value", NodeID = "name",
Group = "group", opacity = 0.4)
getwd()
# Load Libraries
library(ggplot2)
library(reshape)
library(tuneR)
rm(list=ls())
# Create a grid of complex numbers
c.points <- outer(seq(-2.5, 1, by = 0.002),1i*seq(-1.5, 1.5, by = 0.002),'+')
z <- 0
for (k in 1:50) z <- z^2+c.points # Iterations of fractal's formula
c.points <- data.frame(melt(c.points))
colnames(c.points) <- c("r.id", "c.id", "point")
z.points <- data.frame(melt(z))
colnames(z.points) <- c("r.id", "c.id", "z.point")
mandelbrot <- merge(c.points, z.points, by=c("r.id","c.id")) # Mandelbrot Set
# Plotting only finite-module numbers
ggplot(mandelbrot[is.finite(-abs(mandelbrot$z.point)), ], aes(Re(point), Im(point), fill=exp(-abs(z.point))))+
geom_tile()+theme(legend.position="none", axis.title.x = element_blank(), axis.title.y = element_blank())
#####################################################################################
# Function to translate numbers (complex modules) into sounds between 2 frequencies
#   the higher the module is, the lower the frequencie is
#   modules greater than 2 all have same frequencie equal to low.freq
#   module equal to 0 have high.freq
#####################################################################################
Module2Sound <- function (x, low.freq, high.freq)
{
if(x>2 | is.nan(x)) {low.freq} else {x*(low.freq-high.freq)/2+high.freq}
}
#####################################################################################
# Function to create wave. Parameters:
#    complex     : complex number to test
#    number.notes: number of notes to create (notes = iterations)
#    tot.duration.secs: Duration of the wave in seconds
#####################################################################################
CreateSound <- function(complex, number.notes, tot.duration.secs)
{
dur <- tot.duration.secs/number.notes
sep1 <- paste(", bit = 16, duration= ",dur, ", xunit = 'time'),sine(")
sep2 <- paste(", bit = 16, duration =",dur,",  xunit = 'time'))")
v.sounds <- c()
z <- 0
for (k in 1:number.notes)
{
z <- z^2+complex
v.sounds <- c(v.sounds, abs(z))
}
v.freqs <- as.vector(apply(data.frame(v.sounds), 1, FUN=Module2Sound, low.freq=280, high.freq=1046))
eval(parse(text=paste("bind(sine(", paste(as.vector(v.freqs), collapse = sep1), sep2)))
}
sound1 <- CreateSound(-3/4+0.01i     , 400 , 10) # Slow Divergence
sound2 <- CreateSound(-0.1528+1.0397i, 30  , 10) # Feigenbaum Point
sound3 <- CreateSound(-1+0i          , 20  , 10) # Ambulance Siren
writeWave(sound1, 'SlowDivergence.wav')
writeWave(sound2, 'FeigenbaumPoint.wav')
writeWave(sound3, 'AmbulanceSiren.wav')
Module2Sound <- function (x, low.freq, high.freq)
{
if(x>2 | is.nan(x)) {low.freq} else {x*(low.freq-high.freq)/2+high.freq}
}
#####################################################################################
# Function to create wave. Parameters:
#    complex     : complex number to test
#    number.notes: number of notes to create (notes = iterations)
#    tot.duration.secs: Duration of the wave in seconds
#####################################################################################
CreateSound <- function(complex, number.notes, tot.duration.secs)
{
dur <- tot.duration.secs/number.notes
sep1 <- paste(", bit = 32, duration= ",dur, ", xunit = 'time'),sine(")
sep2 <- paste(", bit = 32, duration =",dur,",  xunit = 'time'))")
v.sounds <- c()
z <- 0
for (k in 1:number.notes)
{
z <- z^2+complex
v.sounds <- c(v.sounds, abs(z))
}
v.freqs <- as.vector(apply(data.frame(v.sounds), 1, FUN=Module2Sound, low.freq=280, high.freq=1046))
eval(parse(text=paste("bind(sine(", paste(as.vector(v.freqs), collapse = sep1), sep2)))
}
sound1 <- CreateSound(-3/4+0.01i     , 400 , 10) # Slow Divergence
sound2 <- CreateSound(-0.1528+1.0397i, 30  , 10) # Feigenbaum Point
sound3 <- CreateSound(-1+0i          , 20  , 10) # Ambulance Siren
writeWave(sound1, 'SlowDivergence.wav')
writeWave(sound2, 'FeigenbaumPoint.wav')
writeWave(sound3, 'AmbulanceSiren.wav')
105666764 - 10166997
sceInter <- 10166997
sceTotale <- 105666764
sceIntra <- sceTotale - sceInter
sceIntra
k
k <- 5
n
n <- 96
CMInter <- sceInt / (k-1)
CMInter <- sceInter / (k-1)
CMInter
CMIntra <- sceIntra / (n - k)
CMin
CMInt
CMIntra
Fobs <- CMInter / CMIntra
Fobs
ls
ls()
n
install.packages('spatstat')
DARIUS1959.UTF8 <- read.csv("~/DARIUS1959-UTF8.csv")
View(DARIUS1959.UTF8)
View(DARIUS1959.UTF8[order(DARIUS1959.UTF8$X1959),])
row.names(DARIUS1959.UTF8) <- DARIUS1959.UTF8$AROKATO
View(DARIUS1959.UTF8)
View(DARIUS1959.UTF8)
DARIUS1959.UTF8$Rang1959 <- rank(x=DARIUS1959.UTF8$X1959)
View(DARIUS1959.UTF8)
rank(DARIUS1959.UTF8, decreasing=TRUE)
rank(DARIUS1959.UTF8, decreasing=TRUE)
-rank(DARIUS1959.UTF8)
DARIUS1959.UTF8 <- read.csv("~/DARIUS1959-UTF8.csv")
View(DARIUS1959.UTF8)
DARIUS1959.UTF8 <- DARIUS1959.UTF8[1:150,]
DARIUS1959.UTF8 <- DARIUS1959.UTF8[,c("X1959", "X1970")]
DARIUS1959.UTF8 <- DARIUS1959.UTF8[,c("AROKATO",X1959", "X1970")]
DARIUS1959.UTF8 <- read.csv("~/DARIUS1959-UTF8.csv")
DARIUS1959.UTF8 <- DARIUS1959.UTF8[1:150,c("AROKATO",X1959", "X1970")]
DARIUS1959.UTF8 <- DARIUS1959.UTF8[1:150,c("AROKATO","X1959","X1970")]
DARIUS1959.UTF8 <- read.csv("~/DARIUS1959-UTF8.csv", stringsAsFactor=FALSE)
DARIUS1959.UTF8 <- DARIUS1959.UTF8[1:150,c("AROKATO","X1959","X1970")]
View(DARIUS1959.UTF8)
DARIUS1959.UTF8$rang59 <- rank(-DARIUS1959.UTF8$X1959)
View(DARIUS1959.UTF8)
DARIUS1959.UTF8$rang70 <- rank(-DARIUS1959.UTF8$X1970)
View(DARIUS1959.UTF8)
DARIUS1959.UTF8$diffRang <- DARIUS1959.UTF8$rang70 - DARIUS1959.UTF8$rang59
View(DARIUS1959.UTF8)
plot(x=DARIUS1959.UTF8$rang70, y=DARIUS1959.UTF8$diffRang, type="b")
plot(x=DARIUS1959.UTF8$rang70, y=DARIUS1959.UTF8$diffRang, type="b")
DARIUS1959.UTF8 <- DARIUS1959.UTF8[order(DARIUS1959.UTF8$rang70),]
plot(x=DARIUS1959.UTF8$rang70, y=DARIUS1959.UTF8$diffRang, type="l")
line(x=0:150, y=0)
abline(h=0)
devtools::install_github("rDVR", "johndharrison")
devtools::install_github("RSelenium", "johndharrison")
devtools::install_github("rDVR", "johndharrison")
require(rDVR)
startVServer() # utility function to start a video server
DVR <- rDVR()
DVR$start()
# Do your thing for upto 10 minutes
test123 <- 5
DVR$save()
DVR$closeServer()
require(rDVR)
startVServer()
require(rDVR)
startVServer()
startVideoServer()
checkForVServer()
startVideoServer()
DVR <- rDVR()
DVR$start()
test123 <- 123
c("salut les enfants","ah non en fait")
DVR$save()
DVR$closeServer()
require(shiny)
runApp()
getwd()
setwd("/data/repositories/d3scatter/")
getwd()
runApp()
runApp()
runApp()*
*%*%
runApp()
runApp()
runApp()
runApp()
require(shiny)
runApp()
runApp()
attributesTable <- read.csv("~/visu2/attributesTable.csv")
View(attributesTable)
plot(attributesTable[attributesTable$ID_Temps == 100, ])
vec <- c('hidden', '', '', 'hidden', '')
vec
vec[vec=='hidden'] <- FALSE
vec
vec[vec==''] <- tRUE
vec[vec==''] <- TRUE
vec
require(shiny)
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
require(shiny)
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
require(shiny)
runApp()
runApp()
runApp()
runApp
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
require(shiny)
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
abc
runApp()
abc
str(abc)
class(abc)
as.matrix(abc)
displayDF[1:3,]
as.data.frame(t(abc))
as.data.frame(t(displayDF[dfFilter == TRUE,]))
as.data.frame(t(displayDF[1:4,]))
abc
displayDF[dfFilter == TRUE,]
displayDF[dfFilter == TRUE, drop=FALSE]
displayDF[1:3, drop=FALSE]
displayDF[1:5, drop=FALSE]
displayDF[1:5,, drop=FALSE]
displayDF[1,, drop=FALSE]
runApp()
require(shiny)
runApp()
runApp(launch.browser=rstudio::viewer)
runApp(launch.browser=rstudio::viewer)
runApp(launch.browser=rstudio::viewer)
runApp()
runApp()
runApp()
runApp()
userData()
str(mtcars)
summary(mtcars)
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
require(shiny)
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
?cars
?cart
??cart
runApp()
require(shiny)
runApp()
runApp()
require(shiny)
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
require(shiny)
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
str(mtcars)
mtcars[,c("mpg", "cyl")]
mtcars[,c("mpg", "cyl")]
runApp()
require(shiny)
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
updateColumns <- function(session, columns){
#print(columns)
updateSelectInput(session=session, inputId="columnselection", label="Columns to display", choices=columns, selected="")
}
runApp()
install.packages('shiny')
install.packages("shiny")
require(shiny)
runApp()
runApp()
updateColumns <- function(session, columns, selection=""){
#print(columns)
updateSelectInput(session=session, inputId="columnselection", label="Columns to display", choices=columns, selected=selection)
}
updateColumns <- function(session, columns, selection=""){
#print(columns)
updateSelectInput(session=session, inputId="columnselection", label="Columns to display", choices=columns, selected=selection)
}
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
require(shiny)
runApp()
